{
  "db_name": "PostgreSQL",
  "query": "\n        with passing_candidate_result_data AS (\n            SELECT p.*, c.vote_count\n            FROM passing_candidate_result as p INNER JOIN candidate_result_data as c\n                ON p.voting_id = c.voting_id\n                AND p.name = c.name\n                AND p.round = c.round\n        ),\n        dropped_candidates AS (\n            SELECT name, round, voting_id, vote_count\n            FROM candidate_result_data\n            WHERE (voting_id, round, name) NOT IN (\n                SELECT voting_id, round, name\n                FROM passing_candidate_result\n            )\n        ),\n        round_results AS (\n\n            --- It seems that SQLx is not able to infer that these are nullable\n            --- I suspect that this is related to MATCH SIMPLE in foreign keys.\n            --- Thus we'll force nullability as per https://docs.rs/sqlx/latest/sqlx/macro.query.html#force-nullable\n            --- Similarly we'll force not-null on the COALESCEs.    \n            SELECT\n                r.voting_id as voting_id,\n                r.round as round,\n                d.name as dropped_candidate_name,\n                d.vote_count as dropped_candidate_vote_count,\n                COALESCE(NULLIF(ARRAY_AGG(p.name), '{NULL}'), '{}') as candidate_names,\n                COALESCE(NULLIF(ARRAY_AGG(p.is_selected), '{NULL}'), '{}') as candidate_is_selected,\n                COALESCE(NULLIF(ARRAY_AGG(p.vote_count), '{NULL}'), '{}') as candidate_vote_count\n            FROM\n                voting_round_result as r\n                LEFT JOIN passing_candidate_result_data as p\n                    ON r.voting_id = p.voting_id AND r.round = p.round\n                LEFT JOIN dropped_candidates as d\n                    ON r.voting_id = d.voting_id AND r.round = d.round\n            GROUP BY (r.voting_id, r.round, d.name, d.vote_count)\n        ),\n        candidates_by_voting AS (\n            SELECT v.id, COALESCE(NULLIF(ARRAY_AGG(c.name), '{NULL}'), '{}') as candidates\n            FROM voting AS v LEFT JOIN candidate AS c ON v.id = c.voting_id\n            GROUP BY v.id\n        )\n\n        --- The return type of ARRAY_AGG has to be mangled so it returns an empty list. This is not exactly type safe.\n        SELECT\n            v.id as \"id!: VotingId\",\n            v.state as \"state!: VotingStateWithoutResults\",\n            v.name as \"name!: String\", \n            v.description as \"description!: String\",\n            v.created_at as \"created_at!: DateTime<Utc>\",\n            v.hide_vote_counts as \"hide_vote_counts!: bool\",\n            v.number_of_winners,\n            c.candidates as \"candidates!: Vec<CandidateId>\",\n            r.round as \"round?: i32\",\n            r.dropped_candidate_name as \"dropped_candidate_name?: String\",\n            r.dropped_candidate_vote_count as \"dropped_candidate_vote_count?: f64\",\n            r.candidate_names as \"candidate_names?: Vec<CandidateId>\",\n            r.candidate_is_selected as \"candidate_is_selected?: Vec<bool>\",\n            r.candidate_vote_count as \"candidate_vote_count?: Vec<f64>\",\n            (hv.token_token = $1) as \"you_have_voted?: bool\"\n        FROM\n            voting AS v\n            INNER JOIN candidates_by_voting AS c ON v.id = c.id\n            LEFT JOIN round_results AS r ON v.id = r.voting_id\n            LEFT JOIN has_voted hv on v.id = hv.voting_id and hv.token_token = $1\n        ORDER BY round, v.created_at ASC;\n        ",
  "describe": {
    "columns": [
      {
        "ordinal": 0,
        "name": "id!: VotingId",
        "type_info": "Int4"
      },
      {
        "ordinal": 1,
        "name": "state!: VotingStateWithoutResults",
        "type_info": {
          "Custom": {
            "name": "voting_state",
            "kind": {
              "Enum": [
                "draft",
                "open",
                "closed"
              ]
            }
          }
        }
      },
      {
        "ordinal": 2,
        "name": "name!: String",
        "type_info": "Text"
      },
      {
        "ordinal": 3,
        "name": "description!: String",
        "type_info": "Text"
      },
      {
        "ordinal": 4,
        "name": "created_at!: DateTime<Utc>",
        "type_info": "Timestamptz"
      },
      {
        "ordinal": 5,
        "name": "hide_vote_counts!: bool",
        "type_info": "Bool"
      },
      {
        "ordinal": 6,
        "name": "number_of_winners",
        "type_info": "Int4"
      },
      {
        "ordinal": 7,
        "name": "candidates!: Vec<CandidateId>",
        "type_info": "TextArray"
      },
      {
        "ordinal": 8,
        "name": "round?: i32",
        "type_info": "Int4"
      },
      {
        "ordinal": 9,
        "name": "dropped_candidate_name?: String",
        "type_info": "Text"
      },
      {
        "ordinal": 10,
        "name": "dropped_candidate_vote_count?: f64",
        "type_info": "Float8"
      },
      {
        "ordinal": 11,
        "name": "candidate_names?: Vec<CandidateId>",
        "type_info": "TextArray"
      },
      {
        "ordinal": 12,
        "name": "candidate_is_selected?: Vec<bool>",
        "type_info": "BoolArray"
      },
      {
        "ordinal": 13,
        "name": "candidate_vote_count?: Vec<f64>",
        "type_info": "Float8Array"
      },
      {
        "ordinal": 14,
        "name": "you_have_voted?: bool",
        "type_info": "Bool"
      }
    ],
    "parameters": {
      "Left": [
        "Text"
      ]
    },
    "nullable": [
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      null,
      false,
      false,
      false,
      null,
      null,
      null,
      null
    ]
  },
  "hash": "f76a3b41c5552a525c5960f29ee296fa265db9535ce58c11fb037e8757fad539"
}
